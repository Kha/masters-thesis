\section{Conclusion and Future Work}

In this thesis, we presented the first general tool for formally verifying safe Rust code
and successfully used it to prove the correctness and asymptotic complexity of
a standard algorithm as well as the correctness of a data structure. The tool translates
imperative Rust code into purely functional code by making use of special
guarantees of Rust's type system that are not exhibited by any other major
imperative programming language. Even before optimizing the coverage of the
language, the transformation is general enough to successfully translate 45\% of
the base \rust{core} library, all without the need for any input modifications or annotations.

Now that the basic tooling is in place, we hope to use it for the verification
of many more standard algorithms and data structures that Rust programmers
use and rely on daily. In order to do this, we will invariably have to revisit some
design restrictions mentioned in this thesis. On top of this, we would also
like to (carefully) broaden the semantics we can represent to include some
reasoning about unsafe code that does not depend on a full memory model of Rust.
A verification of the prominent \rust{Vec} type that we still had to axiomatize in
this work may turn out to be a good first step in this direction.

Lastly, we are highly anticipating the next version of Lean focused on
automation that will be released in the beginning of 2017. By combining general
tactics invoking automated provers and custom tactics that we can design in the
new monadic tactic framework for our purposes, we should be able to drastically
lower the verification cost when using our tool. We hope to continue
contributing to the Lean project in order to make it the best interactive
theorem prover available for program verification.