\section{Introduction}

Imperative programming languages are ubiquitous in today's software development,
making them prime targets for formal reasoning. Unfortunately, their semantics
differ from those of mathematics and logic -- the languages of formal methods -- in some
significant details, starting with the very concept of ``variables''. The problem
of mutability is only exacerbated for languages that allow references to
\emph{alias}, or point to the same memory location, enabling non-local mutation.

The standard way of verifying programs in such languages with the help of an
interactive theorem prover is to explicitly model the semantics of the language
in the language of the theorem prover, then translate
the program to this representation (a ``deep'' embedding) and finally prove the
correctness of its formalized behavior. This general approach is very flexible
and allows for the verification of meta programs such as program transformations.
The downside of the approach is that the theorem prover's tools and tactics may
not be directly applicable to the embedded language, defeating many amenities of
modern theorem provers.
Alternatively, programs can be ``shallowly'' embedded by directly translating them
into terms in the theorem prover's language without the use of an explicit inner semantics.
This simplifies many semantic details such as the identification and
substitution of bound variables, but is harder to accomplish the more the semantics
of the source language differs from the theorem prover's own semantics.
\todo{verification condition generators? Move to Related Work?}

Regardless of the type of embedding,
an explicit heap that references can point into must generally be modeled and
passed around in order to deal with the aliasing problem. References in this model may be as simple as
indices into a uniform heap, but various logics such as separation logic~\cite{reynolds2002separation} have been developed to work on a more abstract representation and to express
aliasing-free sets of references.

Languages with more restricted forms of aliasing exist, however.
Rust~\cite{matsakis2014rust}, a new, imperative systems programming language,
imposes on mutable references the restriction of never being aliased by any
other reference, mutable or immutable. This restriction eliminates the
possibility of data races and other common bugs created by the presence of
mutable sharing such as iterator invalidation. It furthermore enables more
aggressive optimizations.

While the full Rust language also provides raw pointers, which are not bound by
the aliasing restriction, and other ``unsafe'' operations, a (informal or formal)
memory model for Rust has yet to be proposed. We therefore focus on the ``safe''
subset of Rust that has no unsolved semantic details.

We utilize safe Rust's aliasing restriction to design a monadic shallow embedding of a
substantial subset of Rust
into the purely functional language of the Lean theorem prover without the need
for any heap-like indirection. This allows us to
reason about unannotated, real-world Rust code in mostly the same manner one would
reason about native Lean definitions. The monadic approach gives us further
flexibility in modeling additional effects such as function runtime.

We first discuss the simpler cases of the
translation, notably excluding mutable references, in \autoref{sec:trans} and
show their application by giving a formal verification of Rust's
\verb!std::[T]::binary_search! method in \autoref{sec:binary_search}.
\autoref{sec:mutref} discusses the translation of most usages of mutable
references, which is used in \autoref{sec:fixedbitset} for a verification of the
\texttt{fixedbitset} crate.